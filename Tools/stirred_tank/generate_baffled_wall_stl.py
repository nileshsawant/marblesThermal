import numpy as np
import struct

def write_stl(filename, vertices, faces):
    """
    Write STL file in binary format.
    vertices: list of (x,y,z) tuples
    faces: list of (v1, v2, v3) indices into vertices
    """
    # Calculate normals
    normals = []
    for face in faces:
        v1 = np.array(vertices[face[0]])
        v2 = np.array(vertices[face[1]])
        v3 = np.array(vertices[face[2]])
        normal = np.cross(v2 - v1, v3 - v1)
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal /= norm
        normals.append(normal)

    with open(filename, 'wb') as f:
        # 80 byte header
        header = b'Binary STL generated by Python script'
        f.write(header + b'\x00' * (80 - len(header)))
        
        # Number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Triangles
        for i, face in enumerate(faces):
            # Normal
            f.write(struct.pack('<3f', *normals[i]))
            
            # Vertices
            for vertex_idx in face:
                f.write(struct.pack('<3f', *vertices[vertex_idx]))
                
            # Attribute byte count
            f.write(struct.pack('<H', 0))

def add_triangle(vertices, faces, p1, p2, p3):
    """
    Add a triangle (p1, p2, p3 in CCW order).
    """
    idx = len(vertices)
    vertices.extend([p1, p2, p3])
    faces.append((idx, idx+1, idx+2))

def add_quad(vertices, faces, p1, p2, p3, p4):
    """
    Add two triangles forming a quad (p1, p2, p3, p4 in CCW order).
    """
    idx = len(vertices)
    vertices.extend([p1, p2, p3, p4])
    faces.append((idx, idx+1, idx+2))
    faces.append((idx, idx+2, idx+3))

def generate_baffled_tank(center, wall_radius, wall_thickness, wall_height, 
                          baffle_length, baffle_width, num_segments=144):
    """
    Generate a hollow tank with integrated baffles.
    The tank is a solid block with a cavity.
    The cavity has indentations for the baffles.
    """
    cx, cy, cz = center
    z_min = cz - wall_height / 2.0
    z_max = cz + wall_height / 2.0
    
    cap_thickness = 4.0
    z_min_in = z_min + cap_thickness
    z_max_in = z_max - cap_thickness
    
    r_outer = wall_radius + wall_thickness
    
    vertices = []
    faces = []
    
    # --- 1. OUTER SHELL (Simple Cylinder) ---
    # Normal OUT
    
    # Generate circle points
    outer_points = []
    for i in range(num_segments):
        theta = 2 * np.pi * i / num_segments
        outer_points.append((cx + r_outer * np.cos(theta), cy + r_outer * np.sin(theta)))
        
    # Extrude Outer Shell
    # Side Walls
    for i in range(num_segments):
        p1 = (*outer_points[i], z_min)
        p2 = (*outer_points[(i+1)%num_segments], z_min)
        p3 = (*outer_points[(i+1)%num_segments], z_max)
        p4 = (*outer_points[i], z_max)
        add_quad(vertices, faces, p1, p2, p3, p4)
        
    # Bottom Cap (Outer) - Normal DOWN
    cb_out = (cx, cy, z_min)
    for i in range(num_segments):
        p1 = (*outer_points[i], z_min)
        p2 = (*outer_points[(i+1)%num_segments], z_min)
        add_triangle(vertices, faces, cb_out, p2, p1)
        
    # Top Cap (Outer) - Normal UP
    ct_out = (cx, cy, z_max)
    for i in range(num_segments):
        p1 = (*outer_points[i], z_max)
        p2 = (*outer_points[(i+1)%num_segments], z_max)
        add_triangle(vertices, faces, ct_out, p1, p2)
        
    # --- 2. INNER SHELL (Cavity with Baffles) ---
    # Normal IN (towards axis)
    
    # Generate Profile Points
    # We iterate through angles and insert baffle points
    profile_points = []
    
    baffle_angles = [0, 90, 180, 270]
    current_angle_idx = 0
    
    # Helper to rotate point (x,y) by angle_deg around (cx,cy)
    def rotate_pt(x, y, angle_rad):
        dx = x - cx
        dy = y - cy
        rx = dx * np.cos(angle_rad) - dy * np.sin(angle_rad)
        ry = dx * np.sin(angle_rad) + dy * np.cos(angle_rad)
        return (cx + rx, cy + ry)

    # Calculate angular width of baffle at radius
    # sin(delta) = (W/2) / R
    delta_rad = np.arcsin((baffle_width/2.0) / wall_radius)
    
    # We will generate points by walking around the circle
    # We use a finer resolution for the arc
    
    # Sort angles just in case
    baffle_angles.sort()
    
    for b_angle_deg in baffle_angles:
        b_angle_rad = np.radians(b_angle_deg)
        
        # Start and End angles for this baffle
        start_b = b_angle_rad - delta_rad
        end_b = b_angle_rad + delta_rad
        
        # Previous baffle end (or 0 if first)
        # We need to handle the wrap around for the loop
        # But simpler: just generate segments between baffles
        pass

    # Let's rebuild the loop properly
    # We have 4 baffles. We generate 4 arcs and 4 baffle shapes.
    
    for i in range(4):
        b_angle_deg = baffle_angles[i]
        next_b_angle_deg = baffle_angles[(i+1)%4]
        if next_b_angle_deg == 0: next_b_angle_deg = 360
        
        b_angle_rad = np.radians(b_angle_deg)
        next_b_angle_rad = np.radians(next_b_angle_deg)
        
        # Baffle i Geometry
        # Local coords relative to baffle center line
        # We are at b_angle_deg.
        # Points: BaseRight, TipRight, TipLeft, BaseLeft
        # BaseRight is at angle -delta
        
        # 1. Baffle Points (CCW)
        # Note: The profile is the CAVITY boundary.
        # The baffle is SOLID. So the cavity goes AROUND it.
        # Wait. The baffle sticks INTO the cavity.
        # So the cavity boundary must go INWARD.
        
        # Points relative to (cx, cy) aligned with X axis (0 deg)
        # BaseRight: (R, -W/2)
        # TipRight:  (R-L, -W/2)
        # TipLeft:   (R-L, W/2)
        # BaseLeft:  (R, W/2)
        
        # Rotate these by b_angle_deg
        pts_local = [
            (wall_radius, -baffle_width/2.0),
            (wall_radius - baffle_length, -baffle_width/2.0),
            (wall_radius - baffle_length, baffle_width/2.0),
            (wall_radius, baffle_width/2.0)
        ]
        
        pts_rotated = []
        for px, py in pts_local:
            # Rotate (px, py)
            # px is radial distance, py is tangential offset
            # Actually, simpler:
            # x = px, y = py. Rotate by b_angle_rad.
            rx = px * np.cos(b_angle_rad) - py * np.sin(b_angle_rad)
            ry = px * np.sin(b_angle_rad) + py * np.cos(b_angle_rad)
            pts_rotated.append((cx + rx, cy + ry))
            
        profile_points.extend(pts_rotated)
        
        # 2. Arc to next baffle
        # Start angle: b_angle + delta
        # End angle: next_b_angle - delta
        
        arc_start = b_angle_rad + delta_rad
        arc_end = next_b_angle_rad - delta_rad
        
        # Number of points for arc
        # Total circumference ~ 2*pi*R
        # Arc length ~ R * (arc_end - arc_start)
        # Step size ~ 2*pi*R / num_segments
        # num_arc_points = int(num_segments * (arc_end - arc_start) / (2*pi))
        n_arc = int(num_segments / 4) # Approx
        
        for j in range(n_arc):
            # Interpolate angle (exclusive of start/end to avoid dupes with baffle base)
            # Actually, we should include points along the arc
            t = (j + 1) / (n_arc + 1)
            ang = arc_start + (arc_end - arc_start) * t
            profile_points.append((cx + wall_radius * np.cos(ang), cy + wall_radius * np.sin(ang)))

    # Now we have the profile polygon (CCW)
    N = len(profile_points)
    
    # Extrude Inner Shell
    # Side Walls (Normal IN -> CCW from inside)
    # p1 is i, p2 is i+1.
    # p1, p2 are on bottom ring?
    # Let's visualize.
    # Looking from axis: p1 is right, p2 is left.
    # Face: p1_bot, p1_top, p2_top, p2_bot ?
    # Normal: (p1_top - p1_bot) x (p2_bot - p1_bot) = (0,0,H) x (dx, dy, 0) = (-Hdy, Hdx, 0).
    # Tangent is (dx, dy). Normal is (-dy, dx).
    # If CCW, tangent points "left". Normal points "in".
    # So we want Normal IN.
    # So (p1_bot, p1_top, p2_top, p2_bot) gives Normal IN?
    # Let's check.
    # v1 = (0,0,H). v2 = (dx, dy, 0).
    # v1 x v2 = (-Hdy, Hdx, 0).
    # If tangent is (1,0) [at 3 o'clock going up], normal is (0,1) [IN].
    # Yes.
    
    for i in range(N):
        p1 = (*profile_points[i], z_min_in)
        p2 = (*profile_points[(i+1)%N], z_min_in)
        p3 = (*profile_points[(i+1)%N], z_max_in)
        p4 = (*profile_points[i], z_max_in)
        
        # Quad: p1, p4, p3, p2
        add_quad(vertices, faces, p1, p4, p3, p2)
        
    # Inner Bottom Cap (Normal UP)
    # Triangle Fan from Center (cx, cy, z_min_in)
    cb_in = (cx, cy, z_min_in)
    for i in range(N):
        p1 = (*profile_points[i], z_min_in)
        p2 = (*profile_points[(i+1)%N], z_min_in)
        add_triangle(vertices, faces, cb_in, p1, p2)
        
    # Inner Top Cap (Normal DOWN)
    # Triangle Fan from Center (cx, cy, z_max_in)
    ct_in = (cx, cy, z_max_in)
    for i in range(N):
        p1 = (*profile_points[i], z_max_in)
        p2 = (*profile_points[(i+1)%N], z_max_in)
        add_triangle(vertices, faces, ct_in, p2, p1)
        
    return vertices, faces

def generate_baffle(center, size, height, angle_deg):
    """
    Generate a rectangular baffle.
    center: (x,y) center of the baffle in XY plane
    size: (length, width) in XY plane
    height: Z height
    angle_deg: rotation angle in degrees
    """
    cx, cy, cz = center
    lx, ly = size
    z_min = cz - height / 2.0
    z_max = cz + height / 2.0
    
    theta = np.radians(angle_deg)
    c, s = np.cos(theta), np.sin(theta)
    
    # Local corners (centered at 0,0)
    corners_local = [
        (-lx/2, -ly/2),
        ( lx/2, -ly/2),
        ( lx/2,  ly/2),
        (-lx/2,  ly/2)
    ]
    
    # Rotate and translate
    corners = []
    for x, y in corners_local:
        xr = x * c - y * s + cx
        yr = x * s + y * c + cy
        corners.append((xr, yr))
        
    vertices = []
    faces = []
    
    p1 = (*corners[0], z_min)
    p2 = (*corners[1], z_min)
    p3 = (*corners[2], z_min)
    p4 = (*corners[3], z_min)
    
    p5 = (*corners[0], z_max)
    p6 = (*corners[1], z_max)
    p7 = (*corners[2], z_max)
    p8 = (*corners[3], z_max)
    
    # Bottom
    add_quad(vertices, faces, p1, p4, p3, p2)
    # Top
    add_quad(vertices, faces, p5, p6, p7, p8)
    # Front
    add_quad(vertices, faces, p1, p2, p6, p5)
    # Right
    add_quad(vertices, faces, p2, p3, p7, p6)
    # Back
    add_quad(vertices, faces, p3, p4, p8, p7)
    # Left
    add_quad(vertices, faces, p4, p1, p5, p8)
    
    return vertices, faces

def merge_meshes(meshes):
    """
    Merge multiple (vertices, faces) tuples into one.
    """
    all_vertices = []
    all_faces = []
    offset = 0
    
    for v, f in meshes:
        all_vertices.extend(v)
        for face in f:
            all_faces.append((face[0] + offset, face[1] + offset, face[2] + offset))
        offset += len(v)
        
    return all_vertices, all_faces

if __name__ == "__main__":
    # Parameters
    center = (64.0, 64.0, 0.0)
    wall_radius = 60.0
    wall_thickness = 100.0
    wall_height = 128.0 # Matches domain Z
    
    baffle_length = 10.0
    baffle_width = 2.0
    # Parameters
    center = (64.0, 64.0, 0.0)
    wall_radius = 60.0
    wall_thickness = 100.0
    wall_height = 128.0 # Matches domain Z
    
    baffle_length = 10.0
    baffle_width = 2.0
    
    meshes = []
    
    # 1. Generate Baffled Tank
    print("Generating Baffled Tank...")
    v_wall, f_wall = generate_baffled_tank(center, wall_radius, wall_thickness, wall_height, 
                                           baffle_length, baffle_width)
    meshes.append((v_wall, f_wall))
    
    # No separate baffles needed!
    
    # Merge and Write
    final_vertices, final_faces = merge_meshes(meshes)
    
    # Is it possible the user is seeing artifacts?
    # Or maybe the "cavity" logic I added in the last turn changed something?
    # In the last turn, I made the wall HOLLOW.
    # The "Solid" is the SHELL.
    # The "Fluid" is the CAVITY.
    # The Baffles are SOLID objects placed INSIDE the CAVITY.
    # If the Baffles are Solid, they should displace the Fluid.
    # If there is "fluid at both ends", it means the Baffles are not extending all the way to the top/bottom of the cavity?
    # But they are 128 high!
    
    # Wait, maybe the user wants the baffles to be merged into the wall geometry?
    # No, that's hard with STL.
    
    # Let's assume the user is right and I made a mistake.
    # Maybe I should make them slightly TALLER than the wall to be safe?
    # Or maybe the user wants them to be part of the CAP?
    
    # Let's try to increase baffle_height to be safe?
    # Or maybe the user wants me to check the "orig_generate_impeller_stl.py"?
    # That's for the impeller.
    
    # Let's look at the wall generation again.
    # z_min = cz - height/2
    # z_max = cz + height/2
    # If height=128, z goes from -64 to 64.
    # Baffles also go from -64 to 64.
    
    # Maybe the user wants the baffles to be THICKER?
    # No, "fluid region at both ends".
    
    # Let's just make sure they are definitely tall enough.
    # I will set baffle_height = wall_height (which is already true).
    
    # Wait, I see "baffle_height = 128.0" in the file.
    # Maybe the user ran an older version?
    # Or maybe the "cavity" is actually larger?
    # z_min_in = z_min + 4.
    # z_max_in = z_max - 4.
    
    # If the baffle is 128, it goes from z_min to z_max.
    # It COVERS the cavity (z_min+4 to z_max-4).
    # It also COVERS the caps (z_min to z_min+4 and z_max-4 to z_max).
    # So it should be solid all the way.
    
    # Unless... the baffle generation has a bug?
    # z_min = cz - height / 2.0
    # z_max = cz + height / 2.0
    # It looks correct.
    
    # Let's assume the user wants me to restore the impeller size first.
    # The user said "check orig_generate_impeller_stl.py".
    # I don't see that file in the file list.
    # But I can infer "original size" from the first read of `generate_impeller_stl.py` in the conversation history.
    # In the first turn, I read:
    # hub_radius = 10.0
    # blade_outer_radius = 15.0
    # blade_thickness = 2.0
    # height = 10.0
    
    # Currently it is:
    # hub_radius = 5.0
    # blade_outer_radius = 7.5
    # blade_thickness = 1.0
    # height = 5.0
    
    # So I need to double these values.
    
    # Back to the baffles.
    # "The tank is open from the top and only partially closed from the bottom" - this was the PREVIOUS complaint.
    # I fixed that by adding caps.
    # Now the complaint is "fluid region at both ends of the baffles".
    # This means the baffles are "floating" in the fluid?
    # Or there is a gap between baffle and cap?
    
    # I will try to make the baffles slightly TALLER than the wall to ensure intersection.
    # Clean up old code
    filename = "baffled_wall.stl"
    print(f"Writing {filename} with {len(final_faces)} triangles...")
    write_stl(filename, final_vertices, final_faces)
    print("Done.")
    
    # Done.
    pass
    
    filename = "baffled_wall.stl"
    print(f"Writing {filename} with {len(final_faces)} triangles...")
    write_stl(filename, final_vertices, final_faces)
    print("Done.")
