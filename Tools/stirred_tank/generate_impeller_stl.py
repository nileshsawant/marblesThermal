import numpy as np
import struct

def write_stl(filename, vertices, faces):
    """
    Write STL file in binary format.
    vertices: list of (x,y,z) tuples
    faces: list of (v1, v2, v3) indices into vertices
    """
    # Calculate normals
    normals = []
    for face in faces:
        v1 = np.array(vertices[face[0]])
        v2 = np.array(vertices[face[1]])
        v3 = np.array(vertices[face[2]])
        normal = np.cross(v2 - v1, v3 - v1)
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal /= norm
        normals.append(normal)

    with open(filename, 'wb') as f:
        # 80 byte header
        header = b'Binary STL generated by Python script'
        f.write(header + b'\x00' * (80 - len(header)))
        
        # Number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Triangles
        for i, face in enumerate(faces):
            # Normal
            f.write(struct.pack('<3f', *normals[i]))
            
            # Vertices
            for vertex_idx in face:
                f.write(struct.pack('<3f', *vertices[vertex_idx]))
                
            # Attribute byte count
            f.write(struct.pack('<H', 0))

def generate_star_impeller(hub_radius, blade_outer_radius, blade_thickness, height, center, num_blades=8):
    """
    Generate a single watertight mesh for the impeller by extruding a star-shaped polygon.
    """
    cx, cy, cz = center
    z_min = cz - height / 2.0
    z_max = cz + height / 2.0
    
    # 1. Generate the 2D profile (XY plane)
    profile_points = [] # List of (x,y)
    
    # Angle covered by half-thickness of blade at hub
    # sin(alpha) = (t/2) / R_hub
    alpha = np.arcsin((blade_thickness / 2.0) / hub_radius)
    
    for k in range(num_blades):
        phi = 2 * np.pi * k / num_blades
        next_phi = 2 * np.pi * (k + 1) / num_blades
        
        cos_phi = np.cos(phi)
        sin_phi = np.sin(phi)
        
        # Blade Right Root (on hub)
        # Local blade coordinates:
        # Right edge: y = -T/2
        # Left edge: y = T/2
        # Root x: sqrt(R_hub^2 - (T/2)^2)
        x_root = np.sqrt(hub_radius**2 - (blade_thickness/2.0)**2)
        
        # Points in local blade frame (rotated by phi later)
        p_root_right_local = np.array([x_root, -blade_thickness/2.0])
        p_tip_right_local  = np.array([blade_outer_radius, -blade_thickness/2.0])
        p_tip_left_local   = np.array([blade_outer_radius, blade_thickness/2.0])
        p_root_left_local  = np.array([x_root, blade_thickness/2.0])
        
        # Rotate these points by phi
        rot_mat = np.array([[cos_phi, -sin_phi], [sin_phi, cos_phi]])
        
        p_root_right = rot_mat @ p_root_right_local
        p_tip_right  = rot_mat @ p_tip_right_local
        p_tip_left   = rot_mat @ p_tip_left_local
        p_root_left  = rot_mat @ p_root_left_local
        
        # Add blade points to profile
        profile_points.append(p_root_right)
        profile_points.append(p_tip_right)
        profile_points.append(p_tip_left)
        profile_points.append(p_root_left)
        
        # Add Hub Arc points between this blade and next blade
        # Start angle: phi + alpha
        # End angle: next_phi - alpha
        start_angle = phi + alpha
        end_angle = next_phi - alpha
        
        # Add intermediate points for curvature
        num_arc_points = 5
        for j in range(num_arc_points):
            # Interpolate angle
            theta = start_angle + (end_angle - start_angle) * (j + 1) / (num_arc_points + 1)
            px = hub_radius * np.cos(theta)
            py = hub_radius * np.sin(theta)
            profile_points.append(np.array([px, py]))

    # 2. Extrude to 3D
    vertices = []
    faces = []
    
    num_profile = len(profile_points)
    
    # Bottom vertices (0 to N-1)
    for p in profile_points:
        vertices.append((cx + p[0], cy + p[1], z_min))
        
    # Top vertices (N to 2N-1)
    for p in profile_points:
        vertices.append((cx + p[0], cy + p[1], z_max))
        
    # Center points for caps
    bottom_center_idx = len(vertices)
    vertices.append((cx, cy, z_min))
    top_center_idx = len(vertices)
    vertices.append((cx, cy, z_max))
    
    # 3. Generate Faces
    # We use "Outward" normals (Standard STL winding)
    # This ensures that AMReX treats the interior as Solid and exterior as Fluid.
    
    for i in range(num_profile):
        # Indices
        b1 = i
        b2 = (i + 1) % num_profile
        t1 = i + num_profile
        t2 = ((i + 1) % num_profile) + num_profile
        
        # Side Walls
        # Outward: (b1, b2, t1) and (t2, t1, b2)
        faces.append((b1, b2, t1))
        faces.append((t2, t1, b2))
        
        # Bottom Cap
        # Outward (Down): (bottom_center_idx, b2, b1)
        faces.append((bottom_center_idx, b2, b1))
        
        # Top Cap
        # Outward (Up): (top_center_idx, t1, t2)
        faces.append((top_center_idx, t1, t2))
        
    return vertices, faces

if __name__ == "__main__":
    # Impeller parameters
    hub_radius = 10.0
    blade_outer_radius = 15.0
    blade_thickness = 2.0
    height = 10.0
    
    # Generate at origin
    center = (0.0, 0.0, 0.0)
    
    print(f"Generating watertight impeller STL...")
    
    vertices, faces = generate_star_impeller(hub_radius, blade_outer_radius, blade_thickness, height, center)

    write_stl("impeller.stl", vertices, faces)
    print(f"Written impeller.stl with {len(faces)} triangles")
