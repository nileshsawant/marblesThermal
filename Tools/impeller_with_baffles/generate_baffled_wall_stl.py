import numpy as np
import struct

def write_stl(filename, vertices, faces):
    """
    Write STL file in binary format.
    vertices: list of (x,y,z) tuples
    faces: list of (v1, v2, v3) indices into vertices
    """
    # Calculate normals
    normals = []
    for face in faces:
        v1 = np.array(vertices[face[0]])
        v2 = np.array(vertices[face[1]])
        v3 = np.array(vertices[face[2]])
        normal = np.cross(v2 - v1, v3 - v1)
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal /= norm
        normals.append(normal)

    with open(filename, 'wb') as f:
        # 80 byte header
        header = b'Binary STL generated by Python script'
        f.write(header + b'\x00' * (80 - len(header)))
        
        # Number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Triangles
        for i, face in enumerate(faces):
            # Normal
            f.write(struct.pack('<3f', *normals[i]))
            
            # Vertices
            for vertex_idx in face:
                f.write(struct.pack('<3f', *vertices[vertex_idx]))
                
            # Attribute byte count
            f.write(struct.pack('<H', 0))

def add_quad(vertices, faces, p1, p2, p3, p4):
    """
    Add two triangles forming a quad (p1, p2, p3, p4 in CCW order).
    """
    idx = len(vertices)
    vertices.extend([p1, p2, p3, p4])
    faces.append((idx, idx+1, idx+2))
    faces.append((idx, idx+2, idx+3))

def generate_cylinder_wall(radius, thickness, height, center, num_segments=72):
    """
    Generate a hollow cylinder wall.
    """
    cx, cy, cz = center
    z_min = cz - height / 2.0
    z_max = cz + height / 2.0
    
    r_inner = radius
    r_outer = radius + thickness
    
    vertices = []
    faces = []
    
    for i in range(num_segments):
        theta1 = 2 * np.pi * i / num_segments
        theta2 = 2 * np.pi * (i + 1) / num_segments
        
        c1, s1 = np.cos(theta1), np.sin(theta1)
        c2, s2 = np.cos(theta2), np.sin(theta2)
        
        # Inner points
        p1_in = (cx + r_inner * c1, cy + r_inner * s1, z_min)
        p2_in = (cx + r_inner * c2, cy + r_inner * s2, z_min)
        p3_in = (cx + r_inner * c2, cy + r_inner * s2, z_max)
        p4_in = (cx + r_inner * c1, cy + r_inner * s1, z_max)
        
        # Outer points
        p1_out = (cx + r_outer * c1, cy + r_outer * s1, z_min)
        p2_out = (cx + r_outer * c2, cy + r_outer * s2, z_min)
        p3_out = (cx + r_outer * c2, cy + r_outer * s2, z_max)
        p4_out = (cx + r_outer * c1, cy + r_outer * s1, z_max)
        
        # Inner face (facing inward)
        add_quad(vertices, faces, p1_in, p4_in, p3_in, p2_in)
        
        # Outer face (facing outward)
        add_quad(vertices, faces, p1_out, p2_out, p3_out, p4_out)
        
        # Top rim
        add_quad(vertices, faces, p4_in, p4_out, p3_out, p3_in)
        
        # Bottom rim
        add_quad(vertices, faces, p1_in, p2_in, p2_out, p1_out)
        
    return vertices, faces

def generate_baffle(center, size, height, angle_deg):
    """
    Generate a rectangular baffle.
    center: (x,y) center of the baffle in XY plane
    size: (length, width) in XY plane
    height: Z height
    angle_deg: rotation angle in degrees
    """
    cx, cy, cz = center
    lx, ly = size
    z_min = cz - height / 2.0
    z_max = cz + height / 2.0
    
    theta = np.radians(angle_deg)
    c, s = np.cos(theta), np.sin(theta)
    
    # Local corners (centered at 0,0)
    corners_local = [
        (-lx/2, -ly/2),
        ( lx/2, -ly/2),
        ( lx/2,  ly/2),
        (-lx/2,  ly/2)
    ]
    
    # Rotate and translate
    corners = []
    for x, y in corners_local:
        xr = x * c - y * s + cx
        yr = x * s + y * c + cy
        corners.append((xr, yr))
        
    vertices = []
    faces = []
    
    p1 = (*corners[0], z_min)
    p2 = (*corners[1], z_min)
    p3 = (*corners[2], z_min)
    p4 = (*corners[3], z_min)
    
    p5 = (*corners[0], z_max)
    p6 = (*corners[1], z_max)
    p7 = (*corners[2], z_max)
    p8 = (*corners[3], z_max)
    
    # Bottom
    add_quad(vertices, faces, p1, p4, p3, p2)
    # Top
    add_quad(vertices, faces, p5, p6, p7, p8)
    # Front
    add_quad(vertices, faces, p1, p2, p6, p5)
    # Right
    add_quad(vertices, faces, p2, p3, p7, p6)
    # Back
    add_quad(vertices, faces, p3, p4, p8, p7)
    # Left
    add_quad(vertices, faces, p4, p1, p5, p8)
    
    return vertices, faces

def merge_meshes(meshes):
    """
    Merge multiple (vertices, faces) tuples into one.
    """
    all_vertices = []
    all_faces = []
    offset = 0
    
    for v, f in meshes:
        all_vertices.extend(v)
        for face in f:
            all_faces.append((face[0] + offset, face[1] + offset, face[2] + offset))
        offset += len(v)
        
    return all_vertices, all_faces

if __name__ == "__main__":
    # Parameters
    center = (330.0, 330.0, 0.0)
    wall_radius = 300.0
    wall_thickness = 400.0
    wall_height = 4.0 # Matches domain Z
    
    baffle_length = 50.0
    baffle_width = 10.0
    baffle_height = 4.0
    
    meshes = []
    
    # 1. Generate Circular Wall
    # Center of wall is at (330, 330, 0)
    # Radius 300
    print("Generating Wall...")
    v_wall, f_wall = generate_cylinder_wall(wall_radius, wall_thickness, wall_height, center)
    meshes.append((v_wall, f_wall))
    
    # 2. Generate 4 Baffles
    # Baffles are attached to the wall and point inward.
    # Wall is at R=300.
    # Baffle length 50.
    # Baffle 1 (Right, 0 deg): Center should be at x = 330 + 300 - 25 = 605, y = 330
    # Baffle 2 (Top, 90 deg): Center should be at x = 330, y = 330 + 300 - 25 = 605
    # ...
    
    print("Generating Baffles...")
    
    # Right (0 deg)
    # Center: (330 + 300 - 25, 330) = (605, 330)
    # Size: (50, 10)
    v_b1, f_b1 = generate_baffle((center[0] + wall_radius - baffle_length/2, center[1], center[2]), 
                                 (baffle_length, baffle_width), baffle_height, 0)
    meshes.append((v_b1, f_b1))
    
    # Top (90 deg)
    # Center: (330, 330 + 300 - 25) = (330, 605)
    # Size: (50, 10) - but rotated 90 deg, so effectively (10, 50) in XY if not rotated
    # Using rotation in generate_baffle:
    v_b2, f_b2 = generate_baffle((center[0], center[1] + wall_radius - baffle_length/2, center[2]), 
                                 (baffle_length, baffle_width), baffle_height, 90)
    meshes.append((v_b2, f_b2))
    
    # Left (180 deg)
    # Center: (330 - 300 + 25, 330) = (55, 330)
    v_b3, f_b3 = generate_baffle((center[0] - wall_radius + baffle_length/2, center[1], center[2]), 
                                 (baffle_length, baffle_width), baffle_height, 180)
    meshes.append((v_b3, f_b3))
    
    # Bottom (270 deg)
    # Center: (330, 330 - 300 + 25) = (330, 55)
    v_b4, f_b4 = generate_baffle((center[0], center[1] - wall_radius + baffle_length/2, center[2]), 
                                 (baffle_length, baffle_width), baffle_height, 270)
    meshes.append((v_b4, f_b4))
    
    # Merge and Write
    final_vertices, final_faces = merge_meshes(meshes)
    
    filename = "baffled_wall.stl"
    print(f"Writing {filename} with {len(final_faces)} triangles...")
    write_stl(filename, final_vertices, final_faces)
    print("Done.")
