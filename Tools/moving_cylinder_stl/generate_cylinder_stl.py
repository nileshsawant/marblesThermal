import numpy as np
import struct

def write_stl(filename, vertices, faces):
    """
    Write STL file in binary format.
    vertices: list of (x,y,z) tuples
    faces: list of (v1, v2, v3) indices into vertices
    """
    # Calculate normals
    normals = []
    for face in faces:
        v1 = np.array(vertices[face[0]])
        v2 = np.array(vertices[face[1]])
        v3 = np.array(vertices[face[2]])
        normal = np.cross(v2 - v1, v3 - v1)
        norm = np.linalg.norm(normal)
        if norm > 0:
            normal /= norm
        normals.append(normal)

    with open(filename, 'wb') as f:
        # 80 byte header
        header = b'Binary STL generated by Python script'
        f.write(header + b'\x00' * (80 - len(header)))
        
        # Number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Triangles
        for i, face in enumerate(faces):
            # Normal
            f.write(struct.pack('<3f', *normals[i]))
            
            # Vertices
            for vertex_idx in face:
                f.write(struct.pack('<3f', *vertices[vertex_idx]))
                
            # Attribute byte count
            f.write(struct.pack('<H', 0))

def generate_cylinder(radius, height, center, num_segments=72):
    """
    Generate cylinder mesh aligned with Z axis.
    """
    cx, cy, cz = center
    z_min = cz - height / 2.0
    z_max = cz + height / 2.0
    
    vertices = []
    faces = []
    
    # Generate vertices for top and bottom circles
    for i in range(num_segments):
        angle = 2 * np.pi * i / num_segments
        x = cx + radius * np.cos(angle)
        y = cy + radius * np.sin(angle)
        
        # Bottom vertex (even indices)
        vertices.append((x, y, z_min))
        # Top vertex (odd indices)
        vertices.append((x, y, z_max))
        
    # Add center points for caps
    bottom_center_idx = len(vertices)
    vertices.append((cx, cy, z_min))
    top_center_idx = len(vertices)
    vertices.append((cx, cy, z_max))
    
    # Generate faces
    for i in range(num_segments):
        # Indices for current segment
        b1 = 2 * i
        t1 = 2 * i + 1
        
        # Indices for next segment (wrapping around)
        b2 = 2 * ((i + 1) % num_segments)
        t2 = 2 * ((i + 1) % num_segments) + 1
        
        # Side faces (2 triangles per segment)
        # Flip winding to reverse normals (if AMReX sees previous as Inward)
        # Previous: (b1, b2, t1) and (t2, t1, b2)
        # New: (b1, t1, b2) and (t2, b2, t1)
        faces.append((b1, t1, b2))
        faces.append((t2, b2, t1))
        
        # Bottom cap
        # Previous: (bottom_center_idx, b2, b1) -> Down
        # New: (bottom_center_idx, b1, b2) -> Up (Into body)
        faces.append((bottom_center_idx, b1, b2))
        
        # Top cap
        # Previous: (top_center_idx, t1, t2) -> Up
        # New: (top_center_idx, t2, t1) -> Down (Into body)
        faces.append((top_center_idx, t2, t1))
        
    return vertices, faces

if __name__ == "__main__":
    radius = 15.0
    height = 1000.0
    # Generate at origin, let AMReX handle translation via stl_center
    center = (0.0, 0.0, 0.0)
    
    print(f"Generating cylinder STL with radius={radius}, height={height}, center={center}")
    
    vertices, faces = generate_cylinder(radius, height, center)
    write_stl("cylinder.stl", vertices, faces)
    
    print(f"Written cylinder.stl with {len(faces)} triangles")
